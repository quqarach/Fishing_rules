<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>–†—ã–±–∞–ª–∫–∞: –º–æ–∂–Ω–æ –∏–ª–∏ –Ω–µ—Ç?</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    body, html {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #map {
      width: 100%;
      height: 100vh;
      background: #eee;
    }

    .date-panel {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 300px;
      background: white;
      padding: 12px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      font-size: 14px;
      max-height: 85vh;
      overflow-y: auto;
    }

    .date-panel h4 {
      margin: 12px 0 6px 0;
      color: #2c3e50;
    }

    .date-panel label {
      display: block;
      margin-bottom: 6px;
      font-weight: bold;
      color: #2c3e50;
    }

    .date-panel input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }

    #restrictions-list {
      max-height: 60vh;
      overflow-y: auto;
      margin-top: 8px;
      border: 1px solid #eee;
      border-radius: 4px;
      padding: 4px 0;
      background-color: #f9f9f9;
    }

    .restriction-item {
      margin-bottom: 6px;
      border: 1px solid #ddd;
      border-radius: 4px;
      overflow: hidden;
    }

    .restriction-title {
      background-color: #f8f8f8;
      padding: 8px;
      cursor: pointer;
      font-weight: bold;
      color: #c62828;
      font-size: 13px;
      margin: 0;
    }

    .restriction-title:hover {
      background-color: #eee;
    }

    .restriction-content {
      padding: 10px;
      background-color: #fff9f9;
      border-top: 1px dashed #ccc;
      display: none;
      font-size: 12px;
      line-height: 1.4;
    }

    .attribution-osm {
      margin-top: 10px;
      font-size: 11px;
      color: #666;
      border-top: 1px solid #eee;
      padding-top: 5px;
    }

    .legal-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #007cba;
      color: white;
      padding: 8px 16px;
      text-align: center;
      font-size: 12px;
      z-index: 1000;
      box-shadow: 0 -2px 4px rgba(0,0,0,0.2);
      line-height: 1.4;
    }

    .popup-info {
      font-size: 13px;
      line-height: 1.5;
    }

    .popup-info strong {
      font-weight: bold;
    }

    .popup-info .status {
      margin-top: 8px;
      font-weight: bold;
    }

    .popup-info .status.ok {
      color: #2e7d32;
    }

    .popup-info .status.error {
      color: #c62828;
    }

    .popup-info .status.warning {
      color: #c68000;
    }

    .popup-info .reason {
      margin-top: 6px;
      padding: 6px;
      background-color: #fff0f0;
      border-left: 3px solid #c62828;
      font-size: 12px;
    }
  </style>
</head>
<body>

  <div class="date-panel">
    <label for="fishing-date">–í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É:</label>
    <input type="date" id="fishing-date" />

    <h4>–û–±—â–∏–µ –ø—Ä–∞–≤–∏–ª–∞ –Ω–∞ –¥–∞—Ç—É:</h4>
    <div id="restrictions-list">
      <p style="color: #999; font-size: 13px; text-align: center; margin: 8px 0;">–ó–∞–≥—Ä—É–∑–∫–∞ –ø—Ä–∞–≤–∏–ª...</p>
    </div>

    <div class="attribution-osm">
      –î–∞–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã: ¬© <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a>
    </div>
  </div>

  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    if (typeof L === 'undefined') {
      document.getElementById('map').innerHTML = '<p style="color:red">–û—à–∏–±–∫–∞: Leaflet –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω</p>';
    }

    const map = L.map('map', { attributionControl: false }).setView([46.5, 40.5], 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    let zoneLayers = [];
    let generalRules = [];
    let marker = null;

    function formatDate(dateStr) {
      const d = new Date(dateStr);
      return d.toLocaleDateString('ru-RU', { day: '2-digit', month: '2-digit', year: 'numeric' });
    }

    function isDateInRange(target, startStr, endStr) {
      const start = new Date(startStr);
      const end = new Date(endStr);
      const t = new Date(target);
      t.setHours(0,0,0,0);
      start.setHours(0,0,0,0);
      end.setHours(0,0,0,0);
      return t >= start && t <= end;
    }

    L.GeometryUtil = L.extend(L.GeometryUtil || {}, {
      pointInPolygon(latlng, polygonLatLngs) {
        let inside = false;
        const latlngs = polygonLatLngs[0];
        for (let i = 0, j = latlngs.length - 1; i < latlngs.length; j = i++) {
          const xi = latlngs[i].lat, yi = latlngs[i].lng;
          const xj = latlngs[j].lat, yj = latlngs[j].lng;
          const intersect = ((yi > latlng.lng) !== (yj > latlng.lng)) &&
            (latlng.lat < (xj - xi) * (latlng.lng - yi) / (yj - yi) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }
    });

    function isPointNearLine(lat, lng, lineCoords, tolerance = 50) {
      const point = L.latLng(lat, lng);
      for (let i = 0; i < lineCoords.length - 1; i++) {
        const p1 = L.latLng(lineCoords[i][0], lineCoords[i][1]);
        const p2 = L.latLng(lineCoords[i+1][0], lineCoords[i+1][1]);

        const dx = p2.lat - p1.lat;
        const dy = p2.lng - p1.lng;
        const d2 = dx*dx + dy*dy;
        if (d2 === 0) continue;

        const t = Math.max(0, Math.min(1, ((point.lat - p1.lat)*dx + (point.lng - p1.lng)*dy) / d2));
        const proj = L.latLng(p1.lat + t*dx, p1.lng + t*dy);
        if (point.distanceTo(proj) <= tolerance) return true;
      }
      return false;
    }

    function isNearAnyBranch(lat, lng, branches, tolerance = 50) {
      return branches.some(branchCoords => {
        return isPointNearLine(lat, lng, branchCoords, tolerance);
      });
    }

    async function loadZones() {
      try {
        const response = await fetch('rules-zones.json');
        if (!response.ok) throw new Error(`–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å rules-zones.json: ${response.status}`);
        const data = await response.json();

        generalRules = data.general_rules || [];

        zoneLayers.forEach(layer => map.removeLayer(layer));
        zoneLayers = [];

        (data.local_zones || []).forEach(zone => {
          let layer;

          if (zone.type === 'polygon') {
            layer = L.polygon(zone.coords, {
              color: 'green',
              fillColor: '#0f0',
              fillOpacity: 0.3,
              weight: 3
            });
          } else if (zone.type === 'line') {
            layer = L.polyline(zone.coords, {
              color: 'green',
              weight: 6,
              opacity: 0.8
            });
          } else if (zone.type === 'river' && Array.isArray(zone.branches)) {
            const group = L.layerGroup();
            zone.branches.forEach(branchCoords => {
              const branchLayer = L.polyline(branchCoords, {
                color: 'green',
                weight: 6,
                opacity: 0.8
              });
              branchLayer.addTo(group);
            });
            layer = group;
          } else return;

          layer.zoneData = zone;
          layer.addTo(map);
          zoneLayers.push(layer);
        });

        const today = new Date().toISOString().split('T')[0];
        document.getElementById('fishing-date').value = today;
        updateZoneColors(today);
        updateGeneralRules(new Date(today));
      } catch (e) {
        console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏:", e);
        document.getElementById('restrictions-list').innerHTML =
          `<p style="color: red; font-size: 13px;">–û—à–∏–±–∫–∞: ${e.message}</p>`;
      }
    }

    function updateZoneColors(dateStr) {
      const date = new Date(dateStr);
      zoneLayers.forEach(layer => {
        const zone = layer.zoneData;
        const isActivePeriod = isDateInRange(date, zone.start, zone.end);

        // üö® –ö–õ–Æ–ß–ï–í–ê–Ø –õ–û–ì–ò–ö–ê: –°–ö–†–´–í–ê–ï–ú –õ–û–ö–ê–õ–¨–ù–´–ï –ß–ê–°–¢–ò–ß–ù–´–ï –ó–û–ù–´, –ï–°–õ–ò –ï–°–¢–¨ –ì–õ–û–ë–ê–õ–¨–ù–´–ô –ü–û–õ–ù–´–ô –ó–ê–ü–†–ï–¢ –ù–ê –≠–¢–£ –†–ï–ö–£
        if (isActivePeriod && zone.type !== undefined) {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º: –µ—Å—Ç—å –ª–∏ –≥–ª–æ–±–∞–ª—å–Ω–æ–µ –ø–æ–ª–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ, –∫–æ—Ç–æ—Ä–æ–µ –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∫ —ç—Ç–æ–π —Ä–µ–∫–µ?
          const zoneNameLower = zone.name.toLowerCase();
          const globalFullRuleForThisRiver = generalRules.some(globalRule =>
            globalRule.appliesEverywhere &&
            globalRule.ruleType === "full" &&
            isDateInRange(date, globalRule.start, globalRule.end) &&
            (
              globalRule.name.toLowerCase().includes("—Ä. –∫–æ–π—Å—É–≥") ||
              globalRule.name.toLowerCase().includes("—Ä–µ–∫–∞ –∫–æ–π—Å—É–≥") ||
              zoneNameLower.includes("—Ä. –∫–æ–π—Å—É–≥") ||
              zoneNameLower.includes("—Ä–µ–∫–∞ –∫–æ–π—Å—É–≥")
            )
          );

          // –ï—Å–ª–∏ –µ—Å—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ø–æ–ª–Ω—ã–π –∑–∞–ø—Ä–µ—Ç ‚Äî —Å–∫—Ä—ã–≤–∞–µ–º —ç—Ç—É –ª–æ–∫–∞–ª—å–Ω—É—é –∑–æ–Ω—É
          if (globalFullRuleForThisRiver) {
            // –°–∫—Ä—ã–≤–∞–µ–º —Å–ª–æ–π (–¥–µ–ª–∞–µ–º –µ–≥–æ –Ω–µ–≤–∏–¥–∏–º—ã–º)
            if (zone.type === 'polygon') {
              layer.setStyle({ color: 'transparent', fillColor: 'transparent', fillOpacity: 0, weight: 0 });
            } else if (zone.type === 'line' || zone.type === 'river') {
              layer.eachLayer ? 
                layer.eachLayer(sub => sub.setStyle({ color: 'transparent', opacity: 0, weight: 0 })) :
                layer.setStyle({ color: 'transparent', opacity: 0, weight: 0 });
            }
            return; // –ù–µ –ø—Ä–∏–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç–∞ ‚Äî —Å–ª–æ–π —Å–∫—Ä—ã—Ç
          }
        }

        // –ï—Å–ª–∏ –∑–æ–Ω–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞ ‚Äî –∑–µ–ª–µ–Ω—ã–π —Ü–≤–µ—Ç
        if (!isActivePeriod) {
          if (zone.type === 'polygon') {
            layer.setStyle({ color: 'green', fillColor: '#0f0', fillOpacity: 0.3, weight: 3 });
          } else if (zone.type === 'line' || zone.type === 'river') {
            layer.eachLayer ? 
              layer.eachLayer(sub => sub.setStyle({ color: 'green', opacity: 0.8, weight: 6 })) :
              layer.setStyle({ color: 'green', opacity: 0.8, weight: 6 });
          }
          return;
        }

        // –ï—Å–ª–∏ –∑–æ–Ω–∞ –∞–∫—Ç–∏–≤–Ω–∞ ‚Äî –ø—Ä–∏–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç –ø–æ —Ç–∏–ø—É –ø—Ä–∞–≤–∏–ª–∞
        const rule = generalRules.find(r => r.name === zone.name);
        const ruleType = zone.ruleType || rule?.type || 'full';

        if (zone.type === 'polygon') {
          if (ruleType === 'partial') {
            layer.setStyle({ color: '#ff8f00', fillColor: '#ffb300', fillOpacity: 0.4, weight: 3 });
          } else {
            layer.setStyle({ color: 'red', fillColor: '#f00', fillOpacity: 0.3, weight: 3 });
          }
        } else if (zone.type === 'line' || zone.type === 'river') {
          const style = ruleType === 'partial' ? { color: '#ff8f00', opacity: 0.9, weight: 8 } : { color: 'red', opacity: 0.9, weight: 8 };
          layer.eachLayer ? 
            layer.eachLayer(sublayer => sublayer.setStyle(style)) :
            layer.setStyle(style);
        }
      });
    }

    function updateGeneralRules(date) {
      const container = document.getElementById('restrictions-list');
      container.innerHTML = '';

      const active = generalRules.filter(rule => isDateInRange(date, rule.start, rule.end));

      if (active.length === 0) {
        container.innerHTML = '<p style="color: #999; font-size: 13px; text-align: center; margin: 8px 0;">–ù–µ—Ç –¥–µ–π—Å—Ç–≤—É—é—â–∏—Ö –æ–±—â–∏—Ö –ø—Ä–∞–≤–∏–ª</p>';
      } else {
        active.forEach(rule => {
          const item = document.createElement('div');
          item.className = 'restriction-item';

          const title = document.createElement('div');
          title.className = 'restriction-title';
          title.textContent = rule.name;
          title.style.cursor = 'pointer';

          const content = document.createElement('div');
          content.className = 'restriction-content';
          content.innerHTML = rule.rule;
          content.style.display = 'none';

          title.onclick = () => {
            content.style.display = content.style.display === 'block' ? 'none' : 'block';
          };

          item.appendChild(title);
          item.appendChild(content);
          container.appendChild(item);
        });
      }
    }

    map.on('click', function(e) {
      const lat = e.latlng.lat;
      const lng = e.latlng.lng;
      const dateStr = document.getElementById('fishing-date').value;
      const date = new Date(dateStr);

      if (marker) map.removeLayer(marker);
      marker = L.marker([lat, lng]).addTo(map);

      let locationName = null;
      let fullRestrictions = [];
      let partialRestrictions = [];

      for (const layer of zoneLayers) {
        const zone = layer.zoneData;
        const isActivePeriod = isDateInRange(date, zone.start, zone.end);
        let isInside = false;

        if (zone.type === 'polygon') {
          isInside = L.GeometryUtil.pointInPolygon(e.latlng, layer.getLatLngs());
        } else if (zone.type === 'line') {
          isInside = isPointNearLine(lat, lng, zone.coords, 50);
        } else if (zone.type === 'river') {
          isInside = isNearAnyBranch(lat, lng, zone.branches, 50);
        }

        if (isInside && isActivePeriod) {
          locationName = zone.name;
          const rule = generalRules.find(r => r.name === zone.name);
          const ruleType = zone.ruleType || rule?.type || 'full';
          if (ruleType === 'partial') {
            partialRestrictions.push(rule?.rule || zone.rule);
          } else {
            fullRestrictions.push(zone.rule);
          }
        }
      }

      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∏–ª–∞ ‚Äî –æ–Ω–∏ –∏–º–µ—é—Ç –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç!
      generalRules.forEach(rule => {
        if (rule.appliesEverywhere && isDateInRange(date, rule.start, rule.end)) {
          if (rule.type === 'partial') {
            partialRestrictions.push(rule.rule);
          } else {
            fullRestrictions.push(rule.rule);
          }
        }
      });

      let status, statusClass;
      if (fullRestrictions.length > 0) {
        status = '‚ùå –†—ã–±–∞–ª–∫–∞ –∑–∞–ø—Ä–µ—â–µ–Ω–∞.';
        statusClass = 'error';
      } else if (partialRestrictions.length > 0) {
        status = '‚ö†Ô∏è –†—ã–±–∞–ª–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∞, –Ω–æ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏.';
        statusClass = 'warning';
      } else {
        status = '‚úÖ –†—ã–±–∞–ª–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∞ –ø—Ä–∏ —Å–æ–±–ª—é–¥–µ–Ω–∏–∏ –æ–±—â–∏—Ö –ø—Ä–∞–≤–∏–ª';
        statusClass = 'ok';
      }

      const reasons = [...fullRestrictions, ...partialRestrictions]
        .map(r => `<div class="reason">${r}</div>`)
        .join('');

      marker.bindPopup(`
        <div class="popup-info">
          <strong>–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã:</strong> ${lat.toFixed(6)}, ${lng.toFixed(6)}<br>
          ${locationName ? `<strong>–õ–æ–∫–∞—Ü–∏—è:</strong> ${locationName}<br>` : ''}
          <strong>–î–∞—Ç–∞:</strong> ${formatDate(dateStr)}<br>
          <strong>–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:</strong><br>
          <span class="status ${statusClass}">${status}</span>
          ${reasons}
        </div>
      `).openPopup();
    });

    document.getElementById('fishing-date').addEventListener('change', function() {
      const date = new Date(this.value);
      updateZoneColors(this.value);
      updateGeneralRules(date);
    });

    loadZones();
  </script>

  <div class="legal-banner">
    –°–æ–≥–ª–∞—Å–Ω–æ –ü—Ä–∏–∫–∞–∑—É –ú–∏–Ω–∏—Å—Ç–µ—Ä—Å—Ç–≤–∞ —Å–µ–ª—å—Å–∫–æ–≥–æ —Ö–æ–∑—è–π—Å—Ç–≤–∞ –†–§ –æ—Ç 9 —è–Ω–≤–∞—Ä—è 2020 –≥. ‚Ññ 1<br>
    "–û–± —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏ –ø—Ä–∞–≤–∏–ª —Ä—ã–±–æ–ª–æ–≤—Å—Ç–≤–∞ –¥–ª—è –ê–∑–æ–≤–æ-–ß–µ—Ä–Ω–æ–º–æ—Ä—Å–∫–æ–≥–æ —Ä—ã–±–æ—Ö–æ–∑—è–π—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –±–∞—Å—Å–µ–π–Ω–∞"<br>
    (—Å –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏ –∏ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏—è–º–∏ –æ—Ç 28 –∏—é–ª—è 2025 –≥.)
  </div>
</body>
</html>
